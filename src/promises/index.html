<html>
<head>
    </head>
<body>

<h1>PromisesPromises</h1>
<p>
What is a promise/

## How do they work?

A promise has a state in which it maintains the following values:
* whether or not its pending
* whether or not its been fulfilled or rejected
* its value
* the reason for rejection if applicable
* a queue of handlers to run when the promise is fulfilled
* a queue of handlers to run when the promise is rejected

The constructor of  Promise is responsible for calling the function that is passed to it, here called the *initial function*, which performs whatever asynchronous actions are required. To this function, the promise passes two callbacks: `fulfil` and `reject`. The initial function calls these according to whether it wants to signal that the process being carried out has succeeded or failed.

### fulfil function
Regardless of how many times the fulfill function is called, it can only set the state of the promise once. At this point it passes from being in a *pending* state to being in either a *fulfilled* or *rejected* state.Once it goes to one, it can't return to a pending state, nor can the value of the promise be changed after being set.
The fulfil function is also responsible for iterating through the fulfilledQueue and calling all the handlers within.

Question: What if you call then() on a function after it has been fulfilled?

> 2.1.1 When pending, a promise:
  2.1.1.1 may transition to either the fulfilled or rejected state.
  2.1.2 When fulfilled, a promise:
    2.1.2.1 must not transition to any other state.
    2.1.2.2 must have a value, which must not change.
  2.1.3 When rejected, a promise:
    2.1.3.1 must not transition to any other state.
    2.1.3.2 must have a reason, which must not change.

#### Adehun
Guard logic

```
  var transition = function (state, value) {
      if (this.state === state ||
              this.state !== validStates.PENDING ||
              !isValidState(state) ||
              arguments.length !== 2) {
          return;
      }

      this.value = value;
      this.state = state;
      this.process();
  };
```

#### Ayepromise
Uses a wrapper that ensures a function is only called once

```
  return {
      resolve: onceWrapper(transparentlyResolveThenablesAndSettle),
      reject: onceWrapper(doReject),
      promise: {
          then: registerThenHandler,
          fail: function (onRejected) {
              return registerThenHandler(null, onRejected);
          }
      }
  };

```
>
2.2.1. Both onFulfilled and onRejected are optional arguments:
  2.2.1.1 If onFulfilled is not a function, it must be ignored.
  2.2.1.2 If onRejected is not a function, it must be ignored.

#### Adehun
```
  if (Utils.isFunction(onFulfilled)) {
      queuedPromise.handlers.fulfill = onFulfilled;
  }

  if (Utils.isFunction(onRejected)) {
      queuedPromise.handlers.reject = onRejected;
  }
```


#### Ayepromise
```
 var callFulfilled = function (value) {
      if (onFulfilled && onFulfilled.call) {
          doHandlerCall(onFulfilled, value);
      } else {
          defer.resolve(value);
      }
  };

  var callRejected = function (value) {
      if (onRejected && onRejected.call) {
          doHandlerCall(onRejected, value);
      } else {
          defer.reject(value);
      }
  };

```
> 
2.2.2 If onFulfilled is a function:
  2.2.2.1 it must be called after promise is fulfilled, with promiseâ€™s value as its first argument.
  2.2.2.2 it must not be called before promise is fulfilled.
  2.2.2.3 it must not be called more than once.

```
  if (that.state === validStates.FULFILLED) {
      handler = queuedPromise.handlers.fulfill || fulfillFallBack;
  } else if (that.state === validStates.REJECTED) {
      handler = queuedPromise.handlers.reject || rejectFallBack;
  }

  try {
      value = handler(that.value);
  } catch (e) {
      queuedPromise.transition(validStates.REJECTED, e);
      continue;
  }

```

> 
2.2.4 onFulfilled or onRejected must not be called until the execution context stack contains only platform code. [3.1].

Adehun
Takes each promise from queue, runs onFulfilled onReject handler asynchronously
```
Utils.runAsync(function () {
  while (that.queue.length) {
      var queuedPromise = that.queue.shift(),
          handler = null,
          value;

      if (that.state === validStates.FULFILLED) {
          handler = queuedPromise.handlers.fulfill || fulfillFallBack;
      } else if (that.state === validStates.REJECTED) {
          handler = queuedPromise.handlers.reject || rejectFallBack;
      }

      try {
          value = handler(that.value);
      } catch (e) {
          queuedPromise.transition(validStates.REJECTED, e);
          continue;
      }

      Resolve(queuedPromise, value);
  }
});


```
Ayepromise

```
  setTimeout(function () {
      var returnValue;
      try {
          returnValue = func(value);
      } catch (e) {
          defer.reject(e);
          return;
      }

      if (returnValue === defer.promise) {
          defer.reject(new TypeError('Cannot resolve promise with itself'));
      } else {
          defer.resolve(returnValue);
      }
  }, 1);

```


### Then
Takes a `onFulfilled` and a `onRejected` handler and returns a promise.

Pushes the promise onto a queue. `then()` can be called multiple times on the same promise.
Each time it is called, the new promise is added to the queue.

> `then()` may be called multiple times on the same promise. (A+ 2.2.6)

Adehun then()
```
  var then = function (onFulfilled, onRejected) {
    // new promise created
    var queuedPromise = new Adehun();
    if (Utils.isFunction(onFulfilled)) {
        queuedPromise.handlers.fulfill = onFulfilled;
    }

    if (Utils.isFunction(onRejected)) {
        queuedPromise.handlers.reject = onRejected;
    }

    // promise queueud
    this.queue.push(queuedPromise);
    this.process();

    // promise returned
    return queuedPromise;
  };

```

Ayepromise then()

```
  var registerThenHandler = function (onFulfilled, onRejected) {
      // new promise created
      var thenHandler = aThenHandler(onFulfilled, onRejected);

      //  promise queued
      if (state === PENDING) {
          thenHandlers.push(thenHandler);
      } else {
          thenHandler.handle(state, outcome);
      }

      // promise returned
      return thenHandler.promise;
  };

```

There must be a mechanism for determining which handler to call when the promise is either fulfilled or rejected

Adehun
```
  if (that.state === validStates.FULFILLED) {
      handler = queuedPromise.handlers.fulfill || fulfillFallBack;
  } else if (that.state === validStates.REJECTED) {
      handler = queuedPromise.handlers.reject || rejectFallBack;
  }

```

Ayepromise
```         
  handle: function (state, value) {
      if (state === FULFILLED) {
          callFulfilled(value);
      } else {
          callRejected(value);
      }
  }

```

The `then` function creates a new Promise and returns it. This promise is resolved by the result returned from calling
either the onFufilled or the onRejected handlers

if the promise is already resolved, either the `onFulfilled` or the `onRejected` handler is called

When the promise if fufilled, it goes from pending: true to pending: false. It gets a value, and its state is set to *fulfilled*
When the promise if fulfilled, all the handlers in the fulfilledQueue are called


</p>


Promises
Investigate:
* How promises work
* make my promises library pass A++ tests
* are promises still relevant with async functions?
* common things that can be done with promises
* common libraries for promises
* extensions to promises

## Future of Promises
It is claimed that Promises.all() can only be done with promises


<script type="text/javascript" src="./sundry.js"></script>
<script type="text/javascript" src="./Promise.js"></script>

<script>

    function callback(val) {
      console.log('callback', val);
    }

    var promise = new PromisesPromises(function(resolve, reject) {
      resolve('hello');
    });

    setTimeout(function () {
      promise.then(callback);
    }, 1000);

</script>

</body>
</html>
